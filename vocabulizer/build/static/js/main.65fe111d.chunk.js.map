{"version":3,"sources":["utils/BEM.ts","utils/inrervals.ts","components/Word/Word.tsx","components/Dictianary/Dictionary.tsx","components/Highlighter/Highlighter.tsx","components/TextArea/TextArea.tsx","components/App/App.tsx","serviceWorker.ts","index.tsx"],"names":["getBEMPAth","b","e","m","base","join","reduce","str","elementName","modifiers","Array","isArray","filter","Boolean","Object","entries","value","map","mergeIntervals","result","interval","isEmpty","concat","init","A","B","AStart","start","AEnd","end","BStart","BEnd","mergeTwoIntervals","last","BEM","Word","word","selected","onSelect","onMarkAsKnown","className","onClick","dictionaryWord","entriesInSrc","length","ev","stopPropagation","Dictionary","dictionary","selectedWords","onSelectWord","known","includes","sort","a","Number","key","partOfSpeechTag","Highlighter","highlighters","text","model","useMemo","src","ranges","breakpoints","flatten","to","from","isHighlighted","append","slice","splitByRanges","index","active","TextArea","props","children","onChange","useState","setValue","useEffect","onInput","currentTarget","defaultValue","React","memo","setSrc","setDictionary","useDebounce","fetch","method","headers","body","JSON","stringify","response","json","words","data","meta","entriesMap","pipe","acc","entry","mapObjIndexed","then","resp","setSelectedWords","dictionaryItem","markAsKnown","source","when","propEq","assoc","selectWord","without","highlighted","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.65fe111d.chunk.js","sourcesContent":["type Modifier = any[] | Record<string, any>\r\ntype B = (b: string) => (elementName?: string | Modifier, modifiers?: Modifier) => string\r\ntype GetBEMPAth = (b: string, e: string, m: string[]) => string\r\n\r\nconst ELEMENT_SEPARATOR = '__'\r\nconst MODIFIER_SEPARATOR = '--'\r\n\r\nconst getBEMPAth: GetBEMPAth = (b, e, m) => {\r\n  const base = e !== '' ? [b, e].join(ELEMENT_SEPARATOR) : b\r\n\r\n  return `${base} ${m.reduce((str, m) => `${str} ${base}${MODIFIER_SEPARATOR}${m}`, '')}`\r\n}\r\n\r\nconst b: B = (b) => (elementName, modifiers = []) => {\r\n  modifiers = typeof elementName === 'string' ? modifiers : elementName || []\r\n\r\n  return getBEMPAth(\r\n    b,\r\n    typeof elementName === 'string' ? elementName : '',\r\n    Array.isArray(modifiers)\r\n      ? modifiers.filter(Boolean)\r\n      : Object.entries(modifiers)\r\n          .filter(([, value]) => Boolean(value))\r\n          .map(([key]) => key),\r\n  )\r\n}\r\n\r\nexport default b\r\n","import { concat, init, isEmpty, last, reduce } from 'ramda'\r\n\r\nexport type Range = { start: number; end: number }\r\n\r\nexport const mergeTwoIntervals = (A: Range, B: Range): Range[] => {\r\n  const AStart = A.start\r\n  const AEnd = A.end\r\n\r\n  const BStart = B.start\r\n  const BEnd = B.end\r\n\r\n  if (AEnd < BStart) return [A, B] // [--A--] ___ [--B--]\r\n  if (BEnd < AStart) return [B, A] // [--B--] ___ [--A--]\r\n\r\n  if (AStart <= BStart && AEnd >= BEnd) return [A] // [ A- [--B--] -A]\r\n  if (BStart <= AStart && BEnd >= AEnd) return [B] // [ B- [--A--] -B]\r\n\r\n  if (AStart <= BStart && AEnd <= BEnd) return [{ start: A.start, end: B.end }] // [A-- [B --A] --B]\r\n  if (BStart <= AStart && BEnd <= AEnd) return [{ start: B.start, end: A.end }] // [B-- [A --B] --A]\r\n\r\n  return [A, B]\r\n}\r\n\r\nexport const mergeIntervals = reduce<Range, Range[]>(\r\n  (result, interval) =>\r\n    isEmpty(result) ? [interval] : concat(init(result), mergeTwoIntervals(last(result) as Range, interval)),\r\n  [],\r\n)\r\n","import React from 'react'\r\nimport { DictionaryItem } from '../../utils/getDictionaryFromSrc'\r\nimport './Word.css'\r\nimport BEM from '../../utils/BEM'\r\n\r\nconst b = BEM('Word')\r\ntype Props = {\r\n  word: DictionaryItem\r\n  onSelect?: (word: DictionaryItem) => void\r\n  onMarkAsKnown?: (word: DictionaryItem) => void\r\n  selected: boolean\r\n}\r\n\r\nexport const Word: React.FunctionComponent<Props> = ({ word, selected, onSelect, onMarkAsKnown }) => (\r\n  <span className={b({ selected })} onClick={() => onSelect?.(word)}>\r\n    {word.dictionaryWord}\r\n    <sub className={b(\"count\")}>{word.entriesInSrc.length}</sub>\r\n    <button className={b(\"close\")} onClick={(ev) => { ev.stopPropagation(); onMarkAsKnown?.(word)}}>x</button>\r\n  </span>\r\n)\r\n","import React, { Fragment } from 'react'\r\nimport { DictionaryItem } from '../../utils/getDictionaryFromSrc'\r\nimport { Word } from '../Word/Word'\r\nimport './Dictionary.css'\r\nimport BEM from '../../utils/BEM'\r\nimport { append, includes, without } from 'ramda'\r\n\r\nconst b = BEM('Dictionary')\r\n\r\ntype Props = {\r\n  selectedWords: string[]\r\n  dictionary: DictionaryItem[]\r\n  onSelectWord?: (word: DictionaryItem, selected: boolean) => void\r\n  onMarkAsKnown?: (word: DictionaryItem, source?: string) => void\r\n}\r\n\r\nexport const Dictionary: React.FunctionComponent<Props> = ({ dictionary, selectedWords, onSelectWord, onMarkAsKnown }) => (\r\n  <div className={b()}>\r\n    {dictionary\r\n      .filter(({ known }) => !known)\r\n      .map(word => ({ word, selected: includes(word.dictionaryWord, selectedWords) }))\r\n      .sort((a, b) => Number(a.selected) - Number(b.selected))\r\n      .map(({word, selected}) => (\r\n      <Fragment key={`${word.dictionaryWord}_${word.partOfSpeechTag}_${word.entriesInSrc.length}`}>\r\n        <Word\r\n          selected={selected}\r\n          word={word}\r\n          onSelect={(word) => onSelectWord?.(word, selected)}\r\n          onMarkAsKnown={(word) => onMarkAsKnown?.(word, 'reading')}\r\n        />{' '}\r\n      </Fragment>\r\n    ))}\r\n  </div>\r\n)\r\n","import React, { useMemo } from 'react'\r\nimport { append, flatten, isEmpty, last, map, reduce, slice } from 'ramda'\r\nimport { Range } from '../../utils/inrervals'\r\nimport './Highlighter.css'\r\nimport BEM from '../../utils/BEM'\r\n\r\nconst b = BEM('Highlighter')\r\n\r\ntype Highlight = [string, boolean]\r\nconst splitByRanges = (src: string, ranges: Range[]): Highlight[] => {\r\n  if (isEmpty(ranges)) return [[src, false]]\r\n\r\n  const breakpoints = flatten(map(({ start, end }) => [start, end], ranges))\r\n  const result = reduce<number, [Highlight[], number, boolean]>(\r\n    ([result, from, isHighlighted], to) => [\r\n      append([slice(from, to, src), isHighlighted], result), //\r\n      to, //\r\n      !isHighlighted,\r\n    ],\r\n    [[], 0, false],\r\n    breakpoints,\r\n  )\r\n\r\n  return append([slice(last(breakpoints) ?? src.length, src.length, src), false], result[0])\r\n}\r\n\r\nexport const Highlighter: React.FunctionComponent<{ highlighters: Range[]; text: string }> = ({\r\n  highlighters,\r\n  text,\r\n}) => {\r\n  const model = useMemo(() => splitByRanges(text, highlighters), [highlighters, text])\r\n\r\n  return (\r\n    <span className={b()}>\r\n      {model.map(([text, isHighlighted], index) => (\r\n        <span key={`${index}____${text}`} className={b('item', { active: isHighlighted })}>\r\n          {text}\r\n        </span>\r\n      ))}\r\n    </span>\r\n  )\r\n}\r\n","import React, { useState, useEffect } from 'react'\r\nimport './TextArea.css'\r\nimport BEM from '../../utils/BEM'\r\nconst b = BEM('TextArea')\r\n\r\ntype Props = {\r\n  onChange?: (vallue: string) => void\r\n  children: (value: string) => React.ReactNode\r\n  value: string\r\n}\r\n\r\nconst TextArea: React.FunctionComponent<Props> = (props) => {\r\n  const { children, onChange } = props\r\n  const [value, setValue] = useState('');\r\n\r\n  useEffect(() => {\r\n    setValue(props.value)\r\n  }, [props.value]);\r\n\r\n  useEffect(() => {\r\n    onChange?.(value)\r\n  }, [value, onChange])\r\n\r\n  return (\r\n    <div className={b()}>\r\n      <textarea onInput={(ev) => setValue(ev.currentTarget.value)} className={b('input')} defaultValue={value} />\r\n      <div className={b('input-highlighter')}>{children(value)}</div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default TextArea\r\n","import { append, assoc, filter, flatten, includes, isEmpty, map, mapObjIndexed, pipe, propEq, reduce, sort, when, without } from 'ramda'\r\nimport React, { useEffect, useMemo, useState } from 'react'\r\nimport { useDebounce } from 'react-use'\r\n// import faker from 'faker'\r\nimport BEM from '../../utils/BEM'\r\nimport { DictionaryItem } from '../../utils/getDictionaryFromSrc'\r\nimport { mergeIntervals, Range } from '../../utils/inrervals'\r\nimport { Dictionary } from '../Dictianary/Dictionary'\r\nimport { Highlighter } from '../Highlighter/Highlighter'\r\nimport TextArea from '../TextArea/TextArea'\r\nimport './App.css'\r\n\r\n\r\nconst b = BEM('App')\r\n\r\nconst App: React.FunctionComponent<{}> = () => {\r\n  const [src, setSrc] = useState<string>('')\r\n  const [dictionary, setDictionary] = useState<DictionaryItem[]>([])\r\n\r\n  useDebounce(\r\n    async () => {\r\n      const response = await fetch('/get-dictionary-from-src', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({ src }),\r\n      })\r\n\r\n      const { data: { words }, meta: { entries } } = await response.json()\r\n\r\n      const entriesMap: Record<string, Range[]> = pipe(\r\n        reduce((acc, entry: any) => ({ ...acc, [entry.word]: entry.entries }), {}),\r\n        mapObjIndexed(flatten),\r\n      )(entries);\r\n\r\n      setDictionary(\r\n        map((word: any) => ({ known: false, ...word, entriesInSrc: entriesMap[word.dictionaryWord] }))(words)\r\n      )\r\n    },\r\n    500,\r\n    [src],\r\n  )\r\n\r\n  useEffect(() => {\r\n    fetch('/text-to-read')\r\n      .then(resp => resp.json())\r\n      .then(({ src }) => setSrc(src))\r\n  }, []);\r\n\r\n  const [selectedWords, setSelectedWords] = useState<string[]>([])\r\n\r\n  const highlighters = useMemo<Range[]>(() => {\r\n    if (isEmpty(selectedWords)) return []\r\n\r\n    return pipe(\r\n      (words: string[]): DictionaryItem[] =>\r\n        filter((dictionaryItem) => !dictionaryItem.known && includes(dictionaryItem.dictionaryWord, words), dictionary),\r\n\r\n      map<DictionaryItem, Range[]>(({ entriesInSrc }) => entriesInSrc),\r\n      flatten,\r\n      sort<Range>((a, b) => a.start - b.start),\r\n      mergeIntervals,\r\n    )(selectedWords)\r\n  }, [selectedWords, dictionary])\r\n\r\n  const markAsKnown = async ({ dictionaryWord, partOfSpeechTag }: DictionaryItem, source?: string) => {\r\n    setDictionary(\r\n      map(\r\n        when(\r\n          propEq('dictionaryWord', dictionaryWord),\r\n          assoc('known', true)\r\n        )\r\n      )(dictionary) as unknown as DictionaryItem[]\r\n    );\r\n\r\n    await fetch('/add-known-word', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify({ dictionaryWord, partOfSpeechTag, source }),\r\n    });\r\n  }\r\n\r\n  const selectWord = async (word: DictionaryItem, selected: boolean) => {\r\n    const words = selected ? without([word.dictionaryWord], selectedWords) : append(word.dictionaryWord, selectedWords);\r\n    setSelectedWords(words);\r\n\r\n    await fetch('/add-to-memorise', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify({ ...word, highlighted: selected }),\r\n    });\r\n  }\r\n\r\n  return (\r\n    <div className={b()}>\r\n      <TextArea value={src} onChange={setSrc}>\r\n        {(value) => <Highlighter text={value} highlighters={highlighters} />}\r\n      </TextArea>\r\n      {dictionary && (\r\n        <Dictionary selectedWords={selectedWords} dictionary={dictionary} onSelectWord={selectWord} onMarkAsKnown={markAsKnown} />\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default React.memo(App)\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './components/App/App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}